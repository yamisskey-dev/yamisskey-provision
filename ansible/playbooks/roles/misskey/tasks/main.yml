- name: Check Cloudflare WARP connection status
  command: warp-cli status
  register: warp_status
  changed_when: false
  failed_when: warp_status.rc != 0 and "Please accept the WARP Terms of Service" not in warp_status.stderr

- name: Enable Cloudflare WARP if not connected
  command: warp-cli connect
  when: "'Connected' not in warp_status.stdout"
  register: warp_connect
  failed_when: warp_connect.rc != 0 and "Please accept the WARP Terms of Service" not in warp_connect.stderr

- name: Retry Cloudflare WARP connection if needed
  command: warp-cli connect
  when: warp_connect is failed and "Please accept the WARP Terms of Service" not in warp_connect.stderr
  register: warp_connect_retry
  retries: 3
  delay: 5
  until: warp_connect_retry is success

- name: Verify Cloudflare WARP connection
  command: warp-cli status
  register: warp_check
  until: warp_check.stdout.find("Connected") != -1
  retries: 5
  delay: 5
  failed_when: warp_check.rc != 0 and "Please accept the WARP Terms of Service" not in warp_check.stderr

- name: Configure system to use Cloudflare WARP DNS
  lineinfile:
    path: /etc/resolv.conf
    state: present
    regexp: '^nameserver'
    line: |
      nameserver 1.1.1.1
      nameserver 1.0.0.1
    create: yes
  become: true

- name: Configure Docker to use Cloudflare WARP DNS
  copy:
    content: |
      {
        "dns": ["1.1.1.1", "1.0.0.1"]
      }
    dest: /etc/docker/daemon.json
  notify: Restart Docker
  become: true

- name: Stop cloudflared service if running
  systemd:
    name: cloudflared
    state: stopped
    enabled: false
  ignore_errors: yes

- name: Find cloudflared UUID file
  find:
    paths: '/home/{{ ansible_user }}/.cloudflared'
    patterns: '*.json'
  register: uuid_files

- name: Set tunnel UUID
  set_fact:
    tunnel_uuid: "{{ item.path | regex_replace('^.*/(.*)\\.json$', '\\1') }}"
  loop: '{{ uuid_files.files }}'
  when: uuid_files.matched > 0
  changed_when: false

- name: Fail if no UUID file is found
  fail:
    msg: 'No cloudflared UUID file found in /home/{{ ansible_user }}/.cloudflared'
  when: uuid_files.matched == 0

- name: Debug tunnel_uuid
  debug:
    msg: 'Tunnel UUID: {{ tunnel_uuid }}'

- name: Set cloudflared config.yml content
  template:
    src: templates/cloudflared.config.yml.j2
    dest: '/etc/cloudflared/config.yml'
    owner: 'root'
    mode: '0600'
  vars:
    tunnel_uuid: '{{ tunnel_uuid }}'
    origincert_path: '/home/{{ ansible_user }}/.cloudflared/cert.pem'
  notify: Restart Cloudflared

- name: Install cloudflared as a system service
  command: cloudflared service install
  args:
    creates: /etc/systemd/system/cloudflared.service

- name: Reload systemd to apply new service file
  command: systemctl daemon-reload

- name: Start and enable cloudflared service
  systemd:
    name: cloudflared
    state: started
    enabled: true
  become: true
  notify: Reload Nginx

- name: Ensure Misskey directory exists
  file:
    path: '{{ misskey_dir }}'
    state: directory
    owner: '{{ user_name }}'
    group: '{{ user_name }}'

- name: Check if required files exist
  stat:
    path: '{{ item }}'
  loop:
    - '{{ misskey_dir }}/docker-compose.yml'
    - '{{ misskey_dir }}/.config/default.yml'
    - '{{ misskey_dir }}/.config/docker.env'
  register: required_files

- name: Fail if required files are missing
  fail:
    msg: 'Required file {{ item.item }} not found'
  when: not item.stat.exists
  loop: '{{ required_files.results }}'

- name: Stash local changes
  shell: git stash
  args:
    chdir: '{{ misskey_dir }}'
  register: stash_output
  ignore_errors: yes

- name: Checkout master branch
  shell: git checkout master
  args:
    chdir: '{{ misskey_dir }}'
  register: git_checkout_output

- name: Pull latest changes
  shell: git pull
  args:
    chdir: '{{ misskey_dir }}'
  register: git_pull_output

- name: Update submodules
  shell: git submodule update --init
  args:
    chdir: '{{ misskey_dir }}'
  register: git_submodule_update_output

- name: Apply stashed changes
  shell: git stash pop
  args:
    chdir: '{{ misskey_dir }}'
  when: stash_output is defined and "'No stash entries found.' not in stash_output.stderr"
  ignore_errors: yes

- name: Check if Misskey is already running
  shell: docker-compose ps -q
  args:
    chdir: '{{ misskey_dir }}'
  register: misskey_running
  failed_when: false

- name: Check if Docker image exists
  shell: docker images -q misskey_web:latest
  register: docker_image
  failed_when: false

- name: Determine if updates are needed
  set_fact:
    updates_needed: "{{ git_pull_output.stdout != 'Already up to date.' or git_submodule_update_output.stdout != '' or docker_image.stdout == '' }}"

- name: Build Misskey image if updates are needed
  shell: |
    IMAGE_TAG="misskey_web:{{ ansible_date_time.iso8601_basic }}"
    COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose build --no-cache --build-arg TAG=$IMAGE_TAG
    docker tag misskey_web:latest $IMAGE_TAG
  args:
    chdir: '{{ misskey_dir }}'
    executable: /bin/bash
  when: updates_needed
  register: build_output
  failed_when: build_output.rc != 0
  ignore_errors: yes

- name: Debug build output
  debug:
    var: build_output
  when: updates_needed

- name: Fail if build failed
  fail:
    msg: "Build of Misskey failed with error: {{ build_output.stderr | default('Unknown error') }}"
  when: updates_needed and build_output.rc != 0

- name: Initialize Misskey database if not already running
  shell: echo y | docker-compose run --rm web pnpm run init
  args:
    chdir: '{{ misskey_dir }}'
    executable: /bin/bash
  when: misskey_running.stdout == "" and updates_needed
  register: init_output
  failed_when: init_output.rc != 0
  ignore_errors: yes

- name: Fail if database initialization failed
  fail:
    msg: "Initialization of Misskey database failed with error: {{ init_output.stderr | default('Unknown error') }}"
  when: misskey_running.stdout == "" and init_output.rc != 0

- name: Stop Misskey services
  shell: docker-compose stop
  args:
    chdir: '{{ misskey_dir }}'

- name: Start Misskey
  shell: docker-compose up -d
  args:
    chdir: '{{ misskey_dir }}'
    executable: /bin/bash
  register: start_output
  failed_when: start_output.rc != 0

- name: Change permissions of files directory to upload files
  file:
    path: '{{ misskey_dir }}/files'
    mode: '0777'

- name: Deploy Nginx configuration for clear net
  template:
    src: templates/nginx_misskey_clear.conf.j2
    dest: /etc/nginx/conf.d/misskey.conf
    owner: root
    group: root
    mode: '0644'
  notify: Reload Nginx

- name: Check if Nginx configuration exists
  stat:
    path: '/etc/nginx/conf.d/misskey.conf'
  register: nginx_conf

- name: Notify user if Nginx configuration does not exist
  fail:
    msg: 'Nginx configuration file /etc/nginx/conf.d/misskey.conf does not exist.'
  when: not nginx_conf.stat.exists

- name: Verify Cloudflare configuration exists
  stat:
    path: '/etc/cloudflare/cloudflare.ini'
  register: cloudflare_conf

- name: Fail if Cloudflare configuration does not exist
  fail:
    msg: 'Cloudflare configuration file /etc/cloudflare/cloudflare.ini does not exist.'
  when: not cloudflare_conf.stat.exists

- name: Reload Nginx if configuration files exist
  systemd:
    name: nginx
    state: reloaded
  when: nginx_conf.stat.exists or nginx_onion_conf.stat.exists or cloudflare_conf.stat.exists

- name: Check if VAPID keys file exists
  stat:
    path: '{{ misskey_dir }}/vapid_keys.txt'
  register: vapid_keys_file

- name: Generate VAPID keys
  when: not vapid_keys_file.stat.exists
  shell: docker run node npx web-push generate-vapid-keys
  register: vapid_keys

- name: Save VAPID keys to a file
  when: not vapid_keys_file.stat.exists
  copy:
    content: '{{ vapid_keys.stdout }}'
    dest: '{{ misskey_dir }}/vapid_keys.txt'

- name: Load VAPID keys from file
  slurp:
    src: '{{ misskey_dir }}/vapid_keys.txt'
  register: vapid_keys_content

- name: Set VAPID keys variables
  set_fact:
    vapid_public_key: "{{ vapid_keys_content.content | b64decode | regex_search('Public Key:\\s*(.+)', '\\1') | first }}"
    vapid_private_key: "{{ vapid_keys_content.content | b64decode | regex_search('Private Key:\\s*(.+)', '\\1') | first }}"

- name: Print VAPID keys
  debug:
    msg:
      - 'Public Key: {{ vapid_public_key }}'
      - 'Private Key: {{ vapid_private_key }}'
